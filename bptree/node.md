B+树是b树的一个变种，B树中所有节点的孩子的个数的最大值称为B树的阶，通常用**M**表示

B树的特点，一个M阶的B+树
* 每个节点最多有M个子树
* 除了根节点之外，每个节点至少有ceil(m/2)个子树 
* 所有的叶子节点包含了所有的key，以及指向这些叶子
* 叶子节点按照key，从小到大进行排序，
* 非叶子节点的子树和key数量相等，只包含当前子树最大/最小的key

B+树作为mysql的存储索引，索引往往按照文件的形式存储在磁盘上，系统从磁盘读取文件到内存中
需要定位到文件所在的位置，文件所在的驻面号，磁道号，扇区号，系统从磁盘读取文件到内存是按照block为基本单位操作的

* B+树的磁盘读写代价比较低，B+树的内部节点只包含关键字，而不包含数据，一次性读取到的key就很到，可以索引到很多的页面
* B+树查询的效率很稳定，内部节点不保存数据，只保存子树的索引，所以，所有的key查询都必须是从根节点开始，查询到叶子节点，效率相当
* B+树方便范围查询，所有的叶子节点形成有序的链表

innodb中的根节点是常驻在内存的（提高查询的性能，避免每次查找都需要访问磁盘上根节点的数据）
innodb是会自动的为表生成一个隐含字段作为主键，int类型，

辅助索引和主键索引
辅助索引，name做辅助索引，id是主键，先用name的辅助索引获得主键，再使用这个主键来查询，相当于查询了两次索引

(覆盖索引，查询效率更高)
普通索引的话，就需要查询两次索引操作（如果普通索引的查询是在覆盖索引情况下，可以直接从索引中获得需要的数据，而不用再访问表）
否则就需要获得主键key，使用主键再去查询一次

# B+树插入数据
1. 首先先定位到数据所在的叶子节点，然后将数据插入到这个节点，插入数据后不能破坏key的从小到大排序
2. 插入数据后key<=M，说明插入成功
3. 如果插入之后，是这个叶子节点的最大值，就需要修改其父节点的索引值
4. 插入该元素之后，key>M,就需要将这个节点分成2个节点，元素的个数分别是floor((M+1)/2),ceil((M+1)/2)
5. 若分裂节点后导致父节点的key>M,父节点也需要进行分裂操作，这样往上的进行递归
如果插入后，key的个数小于M，就直接结束

# B+树删除

* 删除key，当前节点key个数大于等于[M/2],就正常删除，不会影响树的结构
* 删除key后，key个数<[M/2],如果其兄弟节点有多余的关键字，可以借一个key过来
* 如果兄弟节点也没有多余的key，就需要和兄弟进行合并
* 删除某个节点的最大/最小key时，就会涉及父亲节点一直到根节点的索引的修改