B+树是b树的一个变种，B树中所有节点的孩子的个数的最大值称为B树的阶，通常用**M**表示

B树的特点，一个M阶的B+树
* 每个节点最多有M个子树
* 除了根节点之外，每个节点至少有ceil(m/2)个子树 
* 所有的叶子节点包含了所有的key，以及指向这些叶子
* 叶子节点按照key，从小到大进行排序，
* 非叶子节点的子树和key数量相等，只包含当前子树最大/最小的key


b+树优点：
* B+树的磁盘读写代价比较低，B+树的内部节点只包含关键字，而不包含数据，一次性读取到的key就很到，可以索引到很多的页面
* B+树查询的效率很稳定，内部节点不保存数据，只保存子树的索引，所以，所有的key查询都必须是从根节点开始，查询到叶子节点，效率相当
* B+树方便范围查询，所有的叶子节点形成有序的链表



# B+树插入数据
1. 首先先定位到数据所在的叶子节点，然后将数据插入到这个节点，插入数据后不能破坏key的从小到大排序
2. 插入数据后key<=M，说明插入成功
3. 如果插入之后，是这个叶子节点的最大值，就需要修改其父节点的索引值
4. 插入该元素之后，key>M,就需要将这个节点分成2个节点，元素的个数分别是floor((M+1)/2),ceil((M+1)/2)
5. 若分裂节点后导致父节点的key>M,父节点也需要进行分裂操作，这样往上的进行递归
如果插入后，key的个数小于M，就直接结束

# B+树删除

* 删除key，当前节点key个数大于等于[M/2],就正常删除，不会影响树的结构
* 删除key后，key个数<[M/2],如果其兄弟节点有多余的关键字，可以借一个key过来
* 如果兄弟节点也没有多余的key，就需要和兄弟进行合并
* 删除某个节点的最大/最小key时，就会涉及父亲节点一直到根节点的索引的修改

# 并发控制

## Crabbing 算法

基本思想：

1. 先获得父根节点，把根节点锁上。
2. 如果当前在左子树，先把左子树给锁上。
3. 然后再判断，锁上左子树之后，根节点是否能够解锁，如果可以，就把根节点解锁；如此递归下去。

安全节点：

- 如果是查找：读锁根节点、读锁子节点，释放根节点。
- 如果是删除：上写锁，如果当前节点安全，则释放当前锁之前的所有锁，并继续往下走。

在操作时，第一步是先锁定根节点，这可能会成为高并发的瓶颈。实际上，一般情况下 B+ 树都很大，一个叶子节点是改变不了根节点的情况。

减轻根节点锁的情况：

- 在插入数据时，给数据加读锁，在最后的叶子节点才加写锁。
- 但是如果需要分裂，则需要从根节点一路加写锁下来，进行分裂合并操作。

叶子节点的扫描可能会出现死锁。如果同时从前往后和从后往前扫描，相遇的时候可能会出现死锁。因此建议只能从一个方向行走。

# mysql索引

B+树作为mysql的存储索引，索引往往按照文件的形式存储在磁盘上，系统从磁盘读取文件到内存中
需要定位到文件所在的位置，文件所在的驻面号，磁道号，扇区号，系统从磁盘读取文件到内存是按照block为基本单位操作的

innodb中的根节点是常驻在内存的（提高查询的性能，避免每次查找都需要访问磁盘上根节点的数据）
innodb是会自动的为表生成一个隐含字段作为主键，int类型，

辅助索引和主键索引
辅助索引（二级索引）**回表操作**，name做辅助索引，id是主键，先用name的辅助索引获得主键，再使用这个主键来查询，相当于查询了两次索引

(覆盖索引，查询效率更高)
普通索引的话，就需要查询两次索引操作（如果普通索引的查询是在覆盖索引情况下，可以直接从索引中获得需要的数据，而不用再访问表）
否则就需要获得主键key，使用主键再去查询一次

## 联合索引



## 多级索引如何查找数据
现在有一个据出所以能，并且现在建立了多个索引，（class,name,subject,key）
~~~sql
select * from student_score where class_name='1班' and student_name='张小强' and subject_name='数学'
~~~
